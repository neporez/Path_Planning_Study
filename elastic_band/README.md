# EB(Elastic Band)

EB는 A, RRT 와 같이 최적의 경로를 찾아주지만 로봇의 운동학 모델을 고려하지 않은 알고리즘으로 생성된 경로를 보완하는 알고리즘이다.

-----------------------------------------------------------------------------------------------------------------

기본적인 개념 다음과 같다.

1. 경로의 포인트들은 서로를 당기는 내부 수축력이 있기 때문에 포인트끼리 서로 당기게 되어
경로를 팽팽하게 만든다.(당겨진 고무줄과 같다고 생각하면 된다) 이로 인해 기존 경로에서 느슨한 부분을 없앤다.

2. 경로의 각 포인트들은 일정거리 내의 장애물로부터 외부 힘을 받게된다. 이로 인해 1의 과정으로 인해
팽팽해진 경로가 장애물과 닿지 않도록 한다.

3. 결과적으로 내부 수축력과 장애물로 인한 외부 힘으로 인해 경로의 포인트가 재구성된다.

4. 위 1~3 과정을 반복하면 할 수록 기존의 경로가 보완된다.

------------------------------------------------------------------------------------------------------------------

코드로 보면 다음과 같다.

------------------------------------------------------------------------------------------------------------------

### 내부 수축력

<pre>
<code>

 force = [[0, 0, 0]] * n
            for j in range(1, n - 1):
                d = math.sqrt((band[j+1][0] - band[j-1][0])**2 + (band[j+1][1] - band[j-1][1])**2)
                f =  [self.k * (d - self.delta_t) * (band[j+1][0] - 2 * band[j][0] + band[j-1][0])/d, self.k * (d - self.delta_t) *(band[j+1][1] - 2 * band[j][1] + band[j-1][1])/d, 0]
                force[j] = f

            for j in range(n):
                force[j] = [max(-0.5, min(0.5, force[j][0])), max(-0.5, min(0.5, force[j][1])), 0]

</code>
</pre>

force는 경로의 각 포인트마다 적용되는 내부 수축력을 담고 있다

------------------------------------------------------------------------------------------------------------------


### 외부 힘

<pre>
<code>

 repulse = [[0, 0, 0]] * n
            for j in range(1, n - 1):
                if dist[j] < self.d_min:
                    repulse[j] = [(self.d_min - dist[j]) * g for g in self.obs_gradient(band[j][:2], self.obs)]
                elif self.d_min <= dist[j] < self.d_max:
                    repulse[j] = [(self.d_max - dist[j]) * g for g in self.obs_gradient(band[j][:2], self.obs)]
            for j in range(n):
                repulse[j] = [max(-0.5, min(0.5, repulse[j][0])), max(-0.5, min(0.5, repulse[j][1])), 0]

</code>
</pre>

repulse는 경로의 각 포인트마다 적용되는 외부 힘을 담고 있다.

------------------------------------------------------------------------------------------------------------------

결과적으로 두 힘을 합쳐서 경로의 각 포인트마다 적용되어 경로가 보완된다.

<pre>
<code>

 for j in range(n):
                band[j][0] += self.delta_t * force[j][0]
                band[j][1] += self.delta_t * force[j][1]
                band[j][0] += self.delta_t * repulse[j][0]
                band[j][1] += self.delta_t * repulse[j][1]

</code>
</pre>


